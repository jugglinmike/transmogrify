const Transform = require("./transform");
const falafel = require("falafel");

/**
 * Represents a Parser.
 * @constructor
 *
 * @param {String} source is a valid String of JavaScript code.
 * @param {Object} context is an instance of {@link Context}.
 */
function Parser(source, context) {
  /**
   * Valid JavaScript source code.
   * @api public
   */
  this.source = source;

  /**
   * An instance of {@link Context}.
   * @api public
   */
  this.context = context;
}

/**
 * Recieves and processes each Node in the AST generated by Esprima and
 * normalized by falafel.
 *
 * @param {Object} node that represents an entry in the AST.
 * @api private
 */
Parser.prototype._processNode = function(node) {
  // Shorthand the `arguments` property to a non-restricted identifier.
  var args = node.arguments;

  // Exit early if not inspecting a `CallExpression` as we are only interested
  // in function calls.
  if (node.type !== "CallExpression") {
    return;
  }

  // Alias the extracted name of the function to avoid typing it so much.
  var functionName = node.callee.name;

  // If inspecting any registered calls, modify the AST based on the
  // `functionName`.
  if (Object.keys(Transform._transformers).indexOf(functionName) > -1) {
    new Transform(node, args, this.context).modify(functionName);
  }
};

/**
 * Parse the AST and internally process each Node.
 *
 * @return {String} The modified AST.
 * @api public
 */
Parser.prototype.parse = function() {
  return falafel(this.source, this._processNode.bind(this));
};

module.exports = Parser;
